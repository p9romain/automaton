Hello - from /home/p9romain/TÃ©lÃ©chargements/Dev/ST3/rls-linux/reason-language-server
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 1, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"params":{},"jsonrpc":"2.0","method":"initialized"}
Read message 
{"params":{"textDocument":{"version":0,"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans        *)\n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend","languageId":"ocaml","uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}},"jsonrpc":"2.0","method":"textDocument/didOpen"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"position":{"line":62,"character":12}},"jsonrpc":"2.0","id":2}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"range":{"start":{"line":62,"character":8},"end":{"line":62,"character":12}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":3}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"position":{"line":67,"character":8}},"jsonrpc":"2.0","id":4}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"range":{"start":{"line":67,"character":8},"end":{"line":67,"character":8}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":5}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"range":{"start":{"line":67,"character":8},"end":{"line":67,"character":8}},"context":{"only":["refactor","source"],"triggerKind":1,"diagnostics":[]}},"jsonrpc":"2.0","id":6}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 6, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"range":{"start":{"line":67,"character":8},"end":{"line":67,"character":8}},"context":{"only":["refactor","source"],"triggerKind":1,"diagnostics":[]}},"jsonrpc":"2.0","id":7}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"range":{"start":{"line":67,"character":8},"end":{"line":67,"character":8}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":8}
[server] Got a method textDocument/codeAction
[server] processing took 0.0147819519043ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"params":{"id":8},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}},"jsonrpc":"2.0","method":"textDocument/didClose"}
Read message 
{"method":"shutdown","jsonrpc":"2.0","id":9}
