Hello - from /home/p9romain/TÃ©lÃ©chargements/Dev/ST3/rls-linux/reason-language-server
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 1, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"method":"initialized","jsonrpc":"2.0","params":{}}
Read message 
{"method":"textDocument/didOpen","jsonrpc":"2.0","params":{"textDocument":{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend","version":0,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml","languageId":"ocaml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":2,"jsonrpc":"2.0","params":{"position":{"line":0,"character":5},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":3,"jsonrpc":"2.0","params":{"range":{"start":{"line":0,"character":4},"end":{"line":0,"character":5}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":4,"jsonrpc":"2.0","params":{"position":{"line":13,"character":22},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":5,"jsonrpc":"2.0","params":{"range":{"start":{"line":13,"character":22},"end":{"line":13,"character":22}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0228881835938ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":6,"jsonrpc":"2.0","params":{"position":{"line":42,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 6, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":7,"jsonrpc":"2.0","params":{"range":{"start":{"line":42,"character":18},"end":{"line":42,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : .LettLetterer) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":2,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":8,"jsonrpc":"2.0","params":{"position":{"line":42,"character":29},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":4,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":9,"jsonrpc":"2.0","params":{"position":{"line":42,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 9, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":10,"jsonrpc":"2.0","params":{"position":{"line":42,"character":31},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 10, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":11,"jsonrpc":"2.0","params":{"range":{"start":{"line":42,"character":25},"end":{"line":42,"character":31}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":12,"jsonrpc":"2.0","params":{"position":{"line":46,"character":15},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 12, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":13,"jsonrpc":"2.0","params":{"range":{"start":{"line":46,"character":9},"end":{"line":46,"character":15}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":14,"jsonrpc":"2.0","params":{"position":{"line":47,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 14, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":15,"jsonrpc":"2.0","params":{"range":{"start":{"line":47,"character":18},"end":{"line":47,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 15, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":16,"jsonrpc":"2.0","params":{"position":{"line":142,"character":37},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 16, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":17,"jsonrpc":"2.0","params":{"range":{"start":{"line":142,"character":31},"end":{"line":142,"character":37}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 17, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":18,"jsonrpc":"2.0","params":{"position":{"line":172,"character":39},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 18, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":19,"jsonrpc":"2.0","params":{"range":{"start":{"line":172,"character":33},"end":{"line":172,"character":39}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 19, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":20,"jsonrpc":"2.0","params":{"position":{"line":455,"character":43},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 20, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":21,"jsonrpc":"2.0","params":{"range":{"start":{"line":455,"character":37},"end":{"line":455,"character":43}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 21, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":22,"jsonrpc":"2.0","params":{"position":{"line":454,"character":10},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 22, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":23,"jsonrpc":"2.0","params":{"range":{"start":{"line":454,"character":10},"end":{"line":454,"character":10}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 23, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didOpen","jsonrpc":"2.0","params":{"textDocument":{"text":"module type Symbol = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n\nend\n\nmodule type Letter = sig\n\n  type symbol\n\n  include Symbol\n\n  val epsilon : t\n  val is_epsilon : t -> bool\n\n  val get : t -> symbol option\n  val symbol : symbol -> t\n\nend\n\nmodule AddEpsilon(Sym : Symbol) : Letter with type symbol = Sym.t = struct\n\n  type symbol = Sym.t\n  type t = symbol option\n\n  let compare (letter : t) \n              (letter' : t) : int =\n    match letter, letter' with\n    | Some letter, Some letter' -> Sym.compare letter letter'\n    | None, Some _ -> -1\n    | None, None -> 0\n    | Some _, None -> 1 \n\n  let to_string (letter : t) : string =\n    match letter with\n    | None -> \"Îµ\"\n    | Some letter -> Sym.to_string letter\n\n  let epsilon = None\n  let is_epsilon (letter : t) : bool =\n    match letter with\n    | None -> true \n    | _ -> false\n\n  let get (letter : t) : symbol option = letter\n  let symbol (s : symbol) : t = Some s\n\nend","version":0,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/letter/letter.ml","languageId":"ocaml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/letter
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/letter
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/letter/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/letter
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/letter
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didClose","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/letter/letter.ml"}}}
Read message 
{"method":"textDocument/didOpen","jsonrpc":"2.0","params":{"textDocument":{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend","version":0,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml","languageId":"ocaml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":24,"jsonrpc":"2.0","params":{"position":{"line":20,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 24, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":25,"jsonrpc":"2.0","params":{"range":{"start":{"line":20,"character":18},"end":{"line":20,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 25, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":26,"jsonrpc":"2.0","params":{"position":{"line":20,"character":31},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0259876251221ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 26, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":27,"jsonrpc":"2.0","params":{"range":{"start":{"line":20,"character":25},"end":{"line":20,"character":31}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 27, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":28,"jsonrpc":"2.0","params":{"position":{"line":24,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 28, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":29,"jsonrpc":"2.0","params":{"range":{"start":{"line":24,"character":6},"end":{"line":24,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 29, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":30,"jsonrpc":"2.0","params":{"position":{"line":32,"character":10},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0112056732178ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 30, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":31,"jsonrpc":"2.0","params":{"range":{"start":{"line":32,"character":4},"end":{"line":32,"character":10}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 31, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":32,"jsonrpc":"2.0","params":{"position":{"line":45,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 32, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":33,"jsonrpc":"2.0","params":{"range":{"start":{"line":45,"character":6},"end":{"line":45,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00286102294922ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 33, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":34,"jsonrpc":"2.0","params":{"position":{"line":65,"character":16},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 34, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":35,"jsonrpc":"2.0","params":{"range":{"start":{"line":65,"character":10},"end":{"line":65,"character":16}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00286102294922ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 35, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":36,"jsonrpc":"2.0","params":{"position":{"line":172,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 36, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":37,"jsonrpc":"2.0","params":{"range":{"start":{"line":172,"character":6},"end":{"line":172,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 37, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":38,"jsonrpc":"2.0","params":{"position":{"line":185,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 38, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":39,"jsonrpc":"2.0","params":{"range":{"start":{"line":185,"character":3},"end":{"line":185,"character":3}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 39, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":40,"jsonrpc":"2.0","params":{"range":{"start":{"line":185,"character":3},"end":{"line":185,"character":3}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 40, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":41,"jsonrpc":"2.0","params":{"range":{"start":{"line":185,"character":3},"end":{"line":185,"character":3}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 41, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":42,"jsonrpc":"2.0","params":{"range":{"start":{"line":454,"character":10},"end":{"line":454,"character":10}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 42, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":43,"jsonrpc":"2.0","params":{"range":{"start":{"line":185,"character":3},"end":{"line":185,"character":3}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 43, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":44,"jsonrpc":"2.0","params":{"range":{"start":{"line":185,"character":3},"end":{"line":185,"character":3}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 44, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":45,"jsonrpc":"2.0","params":{"range":{"start":{"line":185,"character":3},"end":{"line":185,"character":3}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 45, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":46,"jsonrpc":"2.0","params":{"range":{"start":{"line":454,"character":10},"end":{"line":454,"character":10}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 46, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":47,"jsonrpc":"2.0","params":{"range":{"start":{"line":454,"character":10},"end":{"line":454,"character":10}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 47, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":48,"jsonrpc":"2.0","params":{"range":{"start":{"line":185,"character":3},"end":{"line":185,"character":3}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 48, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didClose","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/didClose","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/didOpen","jsonrpc":"2.0","params":{"textDocument":{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s \\nr2 : %s \\nr3 : %s \\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\nlet () = Printf.printf \"r1 : %s \\nr2 : %s \\nr3 : %s \\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)","version":0,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml","languageId":"ocaml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/hover","id":49,"jsonrpc":"2.0","params":{"position":{"line":31,"character":75},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 49, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":50,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":75},"end":{"line":31,"character":75}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 50, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":51,"jsonrpc":"2.0","params":{"position":{"line":31,"character":75},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0150203704834ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 51, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/hover","id":52,"jsonrpc":"2.0","params":{"position":{"line":30,"character":74},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 52, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":53,"jsonrpc":"2.0","params":{"range":{"start":{"line":30,"character":74},"end":{"line":30,"character":74}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 53, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/hover","id":54,"jsonrpc":"2.0","params":{"position":{"line":26,"character":30},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 54, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":55,"jsonrpc":"2.0","params":{"range":{"start":{"line":26,"character":30},"end":{"line":26,"character":30}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 55, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didOpen","jsonrpc":"2.0","params":{"textDocument":{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend","version":0,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml","languageId":"ocaml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didOpen","jsonrpc":"2.0","params":{"textDocument":{"text":"module type S = sig\n\n  type lt\n  type t\n\n  (* [letter l] creates a regex from the letter [l] *)\n  val letter : lt -> t\n  (* [concat r1 r2] creates a regex by concatenating [r1] and [r2] *)\n  val concat : t -> t -> t\n  (* [concat r1 r2] creates a regex by uniting [r1] and [r2] *)\n  val union : t -> t -> t\n  (* [star r] creates a star regex from [r] *)\n  val star : t -> t\n\n  (* [equals r1 r2] checks if [r1] is the same as [r2] *)\n  val equals : t -> t -> bool\n\n  (* [normalize reg] normalizes [reg]\n    For example, normalize Concat(r1, Concat(r2, r3)) -> Concat(Concat(r1, r2), r3)\n              or normalize Union(r1, Union(r2, r3)) -> Uniont(Union(r1, r2), r3)\n  *)\n  (* val normalize : t -> t *)\n  (* [simplify reg] simplifies [reg] as much as possible *)\n  val simplify : t -> t\n\n  (* [to_string reg] converts [reg] to a string (e.g. for debuging)\n     There is too much parenthesis to avoid ambiguities\n  *)\n  val to_string : t -> string\n  (* [from_string rstring alphabet] parses [rstring] into a regex*)\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t","version":0,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli","languageId":"ocaml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":56,"jsonrpc":"2.0","params":{"position":{"line":23,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 56, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":57,"jsonrpc":"2.0","params":{"range":{"start":{"line":23,"character":12},"end":{"line":23,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 57, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":58,"jsonrpc":"2.0","params":{"position":{"line":23,"character":14},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 58, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":59,"jsonrpc":"2.0","params":{"range":{"start":{"line":23,"character":6},"end":{"line":23,"character":14}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 59, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":60,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":75},"end":{"line":31,"character":75}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 60, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s \\nr2 : %s \\nr3 : %s \\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\nlet () = Printf.printf \"r1 : %s \\nr2 : %s \\nr3 : %s \\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":2,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":61,"jsonrpc":"2.0","params":{"position":{"line":31,"character":80},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 61, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":62,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":80},"end":{"line":31,"character":80}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 62, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":63,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":80},"end":{"line":31,"character":80}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 63, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didOpen","jsonrpc":"2.0","params":{"textDocument":{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend","version":0,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml","languageId":"ocaml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":64,"jsonrpc":"2.0","params":{"position":{"line":109,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 64, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":65,"jsonrpc":"2.0","params":{"range":{"start":{"line":109,"character":0},"end":{"line":133,"character":20}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 65, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":66,"jsonrpc":"2.0","params":{"position":{"line":109,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 66, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n(*   let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans  *)             \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":2,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":67,"jsonrpc":"2.0","params":{"position":{"line":109,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 67, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":68,"jsonrpc":"2.0","params":{"range":{"start":{"line":109,"character":3},"end":{"line":133,"character":20}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 68, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":69,"jsonrpc":"2.0","params":{"range":{"start":{"line":109,"character":3},"end":{"line":133,"character":20}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 69, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/hover","id":70,"jsonrpc":"2.0","params":{"position":{"line":117,"character":9},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0138282775879ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 70, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":71,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":9},"end":{"line":117,"character":9}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 71, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":4,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":72,"jsonrpc":"2.0","params":{"position":{"line":109,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 72, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":73,"jsonrpc":"2.0","params":{"position":{"line":128,"character":14},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 73, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":74,"jsonrpc":"2.0","params":{"range":{"start":{"line":128,"character":14},"end":{"line":128,"character":14}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 74, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":75,"jsonrpc":"2.0","params":{"position":{"line":128,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 75, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":76,"jsonrpc":"2.0","params":{"range":{"start":{"line":128,"character":0},"end":{"line":133,"character":22}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 76, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":77,"jsonrpc":"2.0","params":{"position":{"line":127,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 77, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":78,"jsonrpc":"2.0","params":{"range":{"start":{"line":127,"character":0},"end":{"line":133,"character":22}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 78, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans    *)           \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":6,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":79,"jsonrpc":"2.0","params":{"position":{"line":127,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 79, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":80,"jsonrpc":"2.0","params":{"position":{"line":108,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0238418579102ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 80, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":81,"jsonrpc":"2.0","params":{"range":{"start":{"line":108,"character":0},"end":{"line":114,"character":6}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 81, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":82,"jsonrpc":"2.0","params":{"position":{"line":109,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 82, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":83,"jsonrpc":"2.0","params":{"range":{"start":{"line":109,"character":0},"end":{"line":115,"character":19}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 83, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n(*   let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans *)\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans    *)           \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":8,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":84,"jsonrpc":"2.0","params":{"position":{"line":109,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 84, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":85,"jsonrpc":"2.0","params":{"range":{"start":{"line":109,"character":3},"end":{"line":115,"character":19}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 85, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":86,"jsonrpc":"2.0","params":{"range":{"start":{"line":109,"character":3},"end":{"line":115,"character":19}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 86, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":87,"jsonrpc":"2.0","params":{"position":{"line":125,"character":19},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 87, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":88,"jsonrpc":"2.0","params":{"range":{"start":{"line":125,"character":19},"end":{"line":125,"character":19}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 88, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":89,"jsonrpc":"2.0","params":{"position":{"line":127,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 89, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":90,"jsonrpc":"2.0","params":{"range":{"start":{"line":127,"character":0},"end":{"line":127,"character":5}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 90, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n(*   let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans *)\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans    *)           \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":9,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":91,"jsonrpc":"2.0","params":{"position":{"line":127,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 91, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":92,"jsonrpc":"2.0","params":{"position":{"line":117,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 92, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":93,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":0},"end":{"line":117,"character":2}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 93, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n(*   let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans *)\n\n(*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans    *)           \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":11,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":94,"jsonrpc":"2.0","params":{"position":{"line":117,"character":5},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 94, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n(*   let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans    *)           \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":14,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":95,"jsonrpc":"2.0","params":{"position":{"line":115,"character":19},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 95, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":96,"jsonrpc":"2.0","params":{"position":{"line":109,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 96, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":97,"jsonrpc":"2.0","params":{"range":{"start":{"line":109,"character":0},"end":{"line":109,"character":0}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 97, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\nlet get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans    *)           \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":15,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n    let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans    *)           \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":17,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":98,"jsonrpc":"2.0","params":{"position":{"line":109,"character":4},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 98, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans    *)           \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":18,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":99,"jsonrpc":"2.0","params":{"position":{"line":109,"character":2},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 99, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":100,"jsonrpc":"2.0","params":{"position":{"line":118,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 100, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":101,"jsonrpc":"2.0","params":{"range":{"start":{"line":118,"character":0},"end":{"line":133,"character":28}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 101, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":102,"jsonrpc":"2.0","params":{"position":{"line":117,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 102, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":103,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":0},"end":{"line":133,"character":28}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 103, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(* (*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans    *)    *)        \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":20,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":104,"jsonrpc":"2.0","params":{"position":{"line":117,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 104, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans    *)           \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":22,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":105,"jsonrpc":"2.0","params":{"position":{"line":117,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0200271606445ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 105, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":106,"jsonrpc":"2.0","params":{"position":{"line":134,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 106, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":107,"jsonrpc":"2.0","params":{"range":{"start":{"line":134,"character":0},"end":{"line":134,"character":0}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 107, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans       \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":32,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":108,"jsonrpc":"2.0","params":{"position":{"line":133,"character":19},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 108, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":109,"jsonrpc":"2.0","params":{"position":{"line":117,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 109, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":110,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":0},"end":{"line":117,"character":0}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 110, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\net get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans       \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":33,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\nlet get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans       \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":35,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":111,"jsonrpc":"2.0","params":{"position":{"line":117,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 111, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":112,"jsonrpc":"2.0","params":{"position":{"line":127,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 112, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":113,"jsonrpc":"2.0","params":{"range":{"start":{"line":127,"character":0},"end":{"line":127,"character":0}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 113, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans       \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":36,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":114,"jsonrpc":"2.0","params":{"position":{"line":127,"character":2},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0121593475342ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 114, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":115,"jsonrpc":"2.0","params":{"position":{"line":116,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 115, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":116,"jsonrpc":"2.0","params":{"range":{"start":{"line":116,"character":0},"end":{"line":133,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 116, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":117,"jsonrpc":"2.0","params":{"position":{"line":117,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 117, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":118,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":0},"end":{"line":133,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 118, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans       \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":40,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":119,"jsonrpc":"2.0","params":{"position":{"line":117,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 119, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans   *)     \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":42,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":120,"jsonrpc":"2.0","params":{"position":{"line":117,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.014066696167ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 120, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":121,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":3},"end":{"line":133,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 121, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":122,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":3},"end":{"line":133,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0147819519043ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 122, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":123,"jsonrpc":"2.0","params":{"position":{"line":117,"character":6},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 123, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":124,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":6},"end":{"line":117,"character":6}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 124, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":125,"jsonrpc":"2.0","params":{"position":{"line":117,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 125, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":126,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":0},"end":{"line":133,"character":28}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 126, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(* (*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans   *)     *) \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":44,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":127,"jsonrpc":"2.0","params":{"position":{"line":117,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 127, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans   *)     \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":46,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":128,"jsonrpc":"2.0","params":{"position":{"line":117,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 128, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans   *)     \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":50,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":129,"jsonrpc":"2.0","params":{"position":{"line":117,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 129, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":130,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":0},"end":{"line":133,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 130, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans       \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":56,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":131,"jsonrpc":"2.0","params":{"position":{"line":133,"character":23},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 131, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":132,"jsonrpc":"2.0","params":{"range":{"start":{"line":133,"character":23},"end":{"line":133,"character":23}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0641345977783ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 132, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":133,"jsonrpc":"2.0","params":{"position":{"line":127,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 133, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":134,"jsonrpc":"2.0","params":{"range":{"start":{"line":127,"character":0},"end":{"line":133,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 134, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt-> int -> t\n  val add_transitions : t -> (int * lt * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  (* val get_rid_of_unreachable_states : t -> t *)\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex_mcn_yama : t -> regexp *)\n  (* val to_regex_brzo_mcc : t -> regexp *)\n  (* val from_regex : regexp -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n\n  module LetterSet = Set.Make(Lt)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module StateSet = Set.Make(Int)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) \n      states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = Int.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Lt.compare letter letter' in\n          match c2 with\n          | 0 -> Int.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        Int.compare state1 state1' = 0\n        && Int.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n(*   let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        Int.compare state state' = 0\n    ) \n    automaton.trans        *)\n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt)\n                (state2 : state) : t =\n    if StateSet.mem state1 automaton.states && StateSet.mem state2 automaton.states then\n      if Lt.is_epsilon letter || LetterSet.mem letter automaton.alphabet then\n        { automaton with trans = TransSet.add (state1, letter, state2) automaton.trans }\n      else\n        failwith \"given letter isn't in the automaton's alphabet\"\n    else\n      failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        Int.compare state1 s1 <> 0 || Int.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %d ;\\n\" !i state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %d [peripheries=2] ;\\n\" state \n    ) \n    automaton.ends ;\n    (* Not TransSet iter because I want to merge all transitions between two states *)\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (fun (_, letter, _ : trans) : string -> Lt.to_string letter) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %d -> %d [label=\\\"%s\\\"] ;\\n\" state1 state2 letter\n        )\n        automaton.states\n    ) \n    automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    && \n    (* No epsilon transition or same letter transition from a state *)\n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Lt.compare @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt list) : lt list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt list) \n                      (old_elt : lt) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            (* epsilon transition *)\n            if Lt.is_epsilon elt then\n              false\n            (* first letter *)\n            else if Lt.is_epsilon old_elt then\n              check letters elt\n            (* anything else *)\n            else\n              if Lt.compare old_elt elt = 0 then\n                false\n              else\n                check letters elt\n        in\n        check letters Lt.epsilon\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = -1 + StateSet.fold min automaton.states 1\n    in\n    (* Add it as a new state *)\n    let automaton = add_state automaton start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state Lt.epsilon state\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions\n      \n       Hashtbl mapping all states the set of states accessible with eps transitions :\n       (state, StateSet.t) Hashtbl.t\n     *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              Lt.is_epsilon letter\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                else\n                  StateSet.union acc\n                    @@ StateSet.add state2\n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state\n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n       Hashtbl mapping a set of states to a list of all its transitions from every states in the set\n       (states, (lt * states) list) Hashtbl.t\n\n       expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ], i.e. :\n        - From states 1, 2 and 5, with \"a\", we can get to 1\n        - From states 1, 2 and 5, with \"b\", we can get to 1, 2 or 5 so we add it as a future new state\n        - etc.\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt * states) list * states_set ) : ((lt * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Lt.compare letter' letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt * states) list) \n          (acc : transitions) ->\n        (* Int name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\nend"}],"textDocument":{"version":58,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":135,"jsonrpc":"2.0","params":{"position":{"line":127,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0410079956055ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 135, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":136,"jsonrpc":"2.0","params":{"range":{"start":{"line":127,"character":3},"end":{"line":133,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 136, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":137,"jsonrpc":"2.0","params":{"range":{"start":{"line":127,"character":3},"end":{"line":133,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 137, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":138,"jsonrpc":"2.0","params":{"range":{"start":{"line":127,"character":3},"end":{"line":133,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 138, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":139,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":80},"end":{"line":31,"character":80}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 139, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":140,"jsonrpc":"2.0","params":{"range":{"start":{"line":23,"character":6},"end":{"line":23,"character":14}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 140, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":141,"jsonrpc":"2.0","params":{"position":{"line":10,"character":25},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 141, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":142,"jsonrpc":"2.0","params":{"range":{"start":{"line":10,"character":25},"end":{"line":10,"character":25}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 142, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":143,"jsonrpc":"2.0","params":{"position":{"line":59,"character":11},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 143, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":144,"jsonrpc":"2.0","params":{"range":{"start":{"line":59,"character":11},"end":{"line":59,"character":11}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 144, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":145,"jsonrpc":"2.0","params":{"position":{"line":43,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 145, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":146,"jsonrpc":"2.0","params":{"range":{"start":{"line":42,"character":0},"end":{"line":43,"character":0}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 146, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":147,"jsonrpc":"2.0","params":{"position":{"line":32,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00977516174316ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 147, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":148,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":0},"end":{"line":32,"character":0}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 148, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":149,"jsonrpc":"2.0","params":{"position":{"line":24,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 149, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":150,"jsonrpc":"2.0","params":{"range":{"start":{"line":23,"character":0},"end":{"line":24,"character":0}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 150, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":151,"jsonrpc":"2.0","params":{"position":{"line":31,"character":15},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 151, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":152,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":15},"end":{"line":31,"character":15}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 152, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":153,"jsonrpc":"2.0","params":{"range":{"start":{"line":127,"character":3},"end":{"line":133,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 153, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":154,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":15},"end":{"line":31,"character":15}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 154, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":155,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":15},"end":{"line":31,"character":15}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 155, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":156,"jsonrpc":"2.0","params":{"range":{"start":{"line":10,"character":25},"end":{"line":10,"character":25}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 156, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":157,"jsonrpc":"2.0","params":{"range":{"start":{"line":127,"character":3},"end":{"line":133,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 45.6998348236ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/automaton
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 157, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/automaton/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":158,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":80},"end":{"line":31,"character":80}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 158, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didClose","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton/automaton.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":159,"jsonrpc":"2.0","params":{"position":{"line":31,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 159, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":160,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":0},"end":{"line":31,"character":148}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 160, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s \\nr2 : %s \\nr3 : %s \\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"r1 : %s \\nr2 : %s \\nr3 : %s \\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":4,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":161,"jsonrpc":"2.0","params":{"position":{"line":31,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 161, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":162,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":3},"end":{"line":31,"character":151}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 162, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":163,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":3},"end":{"line":31,"character":151}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 163, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":164,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":3},"end":{"line":31,"character":151}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 164, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/hover","id":165,"jsonrpc":"2.0","params":{"position":{"line":30,"character":52},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 165, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":166,"jsonrpc":"2.0","params":{"range":{"start":{"line":30,"character":52},"end":{"line":30,"character":52}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 166, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":167,"jsonrpc":"2.0","params":{"position":{"line":30,"character":52},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 167, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s \\nr2 : %s \\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"r1 : %s \\nr2 : %s \\nr3 : %s \\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":5,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":168,"jsonrpc":"2.0","params":{"position":{"line":30,"character":51},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 168, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s \\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"r1 : %s \\nr2 : %s \\nr3 : %s \\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":6,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":169,"jsonrpc":"2.0","params":{"position":{"line":30,"character":41},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 169, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"r1 : %s \\nr2 : %s \\nr3 : %s \\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":7,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":170,"jsonrpc":"2.0","params":{"position":{"line":30,"character":31},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 170, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"r1 : %s\\nr2 : %s \\nr3 : %s \\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":8,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":171,"jsonrpc":"2.0","params":{"position":{"line":31,"character":34},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 171, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s \\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":9,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":172,"jsonrpc":"2.0","params":{"position":{"line":31,"character":43},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 172, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":173,"jsonrpc":"2.0","params":{"position":{"line":31,"character":53},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 173, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":174,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":53},"end":{"line":31,"character":53}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 174, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":10,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":175,"jsonrpc":"2.0","params":{"position":{"line":31,"character":52},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 175, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":176,"jsonrpc":"2.0","params":{"position":{"line":31,"character":27},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 176, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":177,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":27},"end":{"line":31,"character":27}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 177, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":12,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":178,"jsonrpc":"2.0","params":{"position":{"line":31,"character":29},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0150203704834ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 178, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":179,"jsonrpc":"2.0","params":{"position":{"line":30,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 179, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":180,"jsonrpc":"2.0","params":{"range":{"start":{"line":30,"character":24},"end":{"line":30,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 180, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"\\r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":13,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":181,"jsonrpc":"2.0","params":{"position":{"line":30,"character":25},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0290870666504ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 181, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":14,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":182,"jsonrpc":"2.0","params":{"position":{"line":30,"character":26},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 182, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":183,"jsonrpc":"2.0","params":{"range":{"start":{"line":30,"character":26},"end":{"line":30,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 183, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":184,"jsonrpc":"2.0","params":{"range":{"start":{"line":30,"character":26},"end":{"line":30,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 184, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":185,"jsonrpc":"2.0","params":{"range":{"start":{"line":30,"character":26},"end":{"line":30,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 185, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\n(* let () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":16,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":186,"jsonrpc":"2.0","params":{"position":{"line":30,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0112056732178ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 186, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":187,"jsonrpc":"2.0","params":{"range":{"start":{"line":30,"character":24},"end":{"line":30,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 187, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":188,"jsonrpc":"2.0","params":{"range":{"start":{"line":30,"character":24},"end":{"line":30,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 188, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":189,"jsonrpc":"2.0","params":{"position":{"line":31,"character":50},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 189, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":190,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":50},"end":{"line":31,"character":50}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 190, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\nlet () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string @@ simplify reg1) (R.to_string @@ simplify reg2) (R.to_string @@ simplify reg3)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":18,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":191,"jsonrpc":"2.0","params":{"position":{"line":31,"character":47},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 191, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":192,"jsonrpc":"2.0","params":{"position":{"line":31,"character":76},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00977516174316ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 192, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":193,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":76},"end":{"line":31,"character":76}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 193, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":194,"jsonrpc":"2.0","params":{"position":{"line":31,"character":79},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 194, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":195,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":71},"end":{"line":31,"character":79}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 195, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":196,"jsonrpc":"2.0","params":{"position":{"line":31,"character":71},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 196, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":197,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":71},"end":{"line":31,"character":71}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 197, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\nlet () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string @@ Rsimplify reg1) (R.to_string @@ Rsimplify reg2) (R.to_string @@ Rsimplify reg3)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":21,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":198,"jsonrpc":"2.0","params":{"position":{"line":31,"character":72},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 198, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\nlet () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string @@ R.simplify reg1) (R.to_string @@ R.simplify reg2) (R.to_string @@ R.simplify reg3)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":24,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/completion","id":199,"jsonrpc":"2.0","params":{"position":{"line":31,"character":73},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 199, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"$/cancelRequest","jsonrpc":"2.0","params":{"id":199}}
Read message 
{"method":"textDocument/completion","id":200,"jsonrpc":"2.0","params":{"position":{"line":31,"character":73},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 200, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":201,"jsonrpc":"2.0","params":{"position":{"line":31,"character":73},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 201, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":202,"jsonrpc":"2.0","params":{"position":{"line":31,"character":58},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 202, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":203,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":58},"end":{"line":31,"character":58}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 203, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\nlet () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" (to_string @@ simplify reg1) (to_string @@ simplify reg2) (to_string @@ simplify reg3)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":36,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/signatureHelp","id":204,"jsonrpc":"2.0","params":{"position":{"line":31,"character":56},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"triggerCharacter":"(","isRetrigger":false}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0128746032715ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 204, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":205,"jsonrpc":"2.0","params":{"position":{"line":31,"character":56},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 205, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":206,"jsonrpc":"2.0","params":{"position":{"line":31,"character":55},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 206, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":207,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":55},"end":{"line":31,"character":55}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 207, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\nmodule R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\nlet () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" R.(to_string @@ simplify reg1) R.(to_string @@ simplify reg2) R.(to_string @@ simplify reg3)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":42,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/completion","id":208,"jsonrpc":"2.0","params":{"position":{"line":31,"character":56},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 208, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"$/cancelRequest","jsonrpc":"2.0","params":{"id":208}}
Read message 
{"method":"textDocument/completion","id":209,"jsonrpc":"2.0","params":{"position":{"line":31,"character":56},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/completion
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 209, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":210,"jsonrpc":"2.0","params":{"position":{"line":31,"character":57},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 210, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":211,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":57},"end":{"line":31,"character":57}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 211, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":212,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":57},"end":{"line":31,"character":57}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 212, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":213,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":57},"end":{"line":31,"character":57}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 213, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":214,"jsonrpc":"2.0","params":{"position":{"line":15,"character":16},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 214, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":215,"jsonrpc":"2.0","params":{"range":{"start":{"line":15,"character":16},"end":{"line":15,"character":16}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 215, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":216,"jsonrpc":"2.0","params":{"range":{"start":{"line":31,"character":15},"end":{"line":31,"character":15}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 216, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":217,"jsonrpc":"2.0","params":{"position":{"line":60,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 217, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":218,"jsonrpc":"2.0","params":{"range":{"start":{"line":59,"character":0},"end":{"line":60,"character":0}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 218, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":219,"jsonrpc":"2.0","params":{"position":{"line":69,"character":4},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 219, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":220,"jsonrpc":"2.0","params":{"range":{"start":{"line":69,"character":4},"end":{"line":69,"character":4}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 220, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":221,"jsonrpc":"2.0","params":{"position":{"line":81,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 221, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":222,"jsonrpc":"2.0","params":{"range":{"start":{"line":81,"character":12},"end":{"line":81,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 222, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            siplifyPlus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":7,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":223,"jsonrpc":"2.0","params":{"position":{"line":81,"character":19},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 223, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            siplify Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":8,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":224,"jsonrpc":"2.0","params":{"position":{"line":81,"character":20},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 224, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":225,"jsonrpc":"2.0","params":{"position":{"line":81,"character":14},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 225, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":226,"jsonrpc":"2.0","params":{"range":{"start":{"line":81,"character":14},"end":{"line":81,"character":14}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 226, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":9,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":227,"jsonrpc":"2.0","params":{"position":{"line":81,"character":15},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 227, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":228,"jsonrpc":"2.0","params":{"position":{"line":81,"character":21},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 228, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":229,"jsonrpc":"2.0","params":{"range":{"start":{"line":81,"character":21},"end":{"line":81,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 229, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":230,"jsonrpc":"2.0","params":{"position":{"line":81,"character":21},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0112056732178ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 230, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify (Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":10,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/signatureHelp","id":231,"jsonrpc":"2.0","params":{"position":{"line":81,"character":22},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"triggerCharacter":"(","isRetrigger":false}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 231, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":232,"jsonrpc":"2.0","params":{"position":{"line":81,"character":23},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00381469726562ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 232, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":233,"jsonrpc":"2.0","params":{"range":{"start":{"line":81,"character":23},"end":{"line":81,"character":23}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 233, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":234,"jsonrpc":"2.0","params":{"position":{"line":81,"character":22},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00286102294922ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 234, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":235,"jsonrpc":"2.0","params":{"range":{"start":{"line":81,"character":22},"end":{"line":81,"character":22}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 235, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":11,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":236,"jsonrpc":"2.0","params":{"position":{"line":81,"character":21},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 236, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":14,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":237,"jsonrpc":"2.0","params":{"position":{"line":81,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 237, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":238,"jsonrpc":"2.0","params":{"position":{"line":81,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 238, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":239,"jsonrpc":"2.0","params":{"range":{"start":{"line":81,"character":12},"end":{"line":81,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 239, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":15,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":240,"jsonrpc":"2.0","params":{"position":{"line":86,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 240, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/hover","id":241,"jsonrpc":"2.0","params":{"position":{"line":98,"character":26},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 241, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":242,"jsonrpc":"2.0","params":{"range":{"start":{"line":98,"character":26},"end":{"line":98,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 242, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":243,"jsonrpc":"2.0","params":{"position":{"line":98,"character":26},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0121593475342ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 243, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":244,"jsonrpc":"2.0","params":{"position":{"line":99,"character":21},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 244, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":245,"jsonrpc":"2.0","params":{"range":{"start":{"line":99,"character":21},"end":{"line":99,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 245, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":246,"jsonrpc":"2.0","params":{"position":{"line":99,"character":21},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 246, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":16,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":247,"jsonrpc":"2.0","params":{"position":{"line":98,"character":38},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 247, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":17,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":248,"jsonrpc":"2.0","params":{"position":{"line":98,"character":26},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 248, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/hover","id":249,"jsonrpc":"2.0","params":{"position":{"line":99,"character":21},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 249, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":250,"jsonrpc":"2.0","params":{"range":{"start":{"line":99,"character":21},"end":{"line":99,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 250, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":251,"jsonrpc":"2.0","params":{"position":{"line":117,"character":32},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 251, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":252,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":32},"end":{"line":117,"character":32}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00286102294922ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 252, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":253,"jsonrpc":"2.0","params":{"position":{"line":114,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 253, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":254,"jsonrpc":"2.0","params":{"range":{"start":{"line":114,"character":12},"end":{"line":114,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 254, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":255,"jsonrpc":"2.0","params":{"position":{"line":116,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 255, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":256,"jsonrpc":"2.0","params":{"range":{"start":{"line":116,"character":12},"end":{"line":116,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 256, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":257,"jsonrpc":"2.0","params":{"position":{"line":116,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 257, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":258,"jsonrpc":"2.0","params":{"position":{"line":118,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 258, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":259,"jsonrpc":"2.0","params":{"range":{"start":{"line":118,"character":12},"end":{"line":118,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 259, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":260,"jsonrpc":"2.0","params":{"position":{"line":116,"character":36},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0121593475342ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 260, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":261,"jsonrpc":"2.0","params":{"range":{"start":{"line":116,"character":36},"end":{"line":116,"character":36}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 261, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":262,"jsonrpc":"2.0","params":{"position":{"line":116,"character":33},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 262, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":263,"jsonrpc":"2.0","params":{"range":{"start":{"line":116,"character":33},"end":{"line":116,"character":36}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 263, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":264,"jsonrpc":"2.0","params":{"position":{"line":116,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 264, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":265,"jsonrpc":"2.0","params":{"range":{"start":{"line":116,"character":24},"end":{"line":116,"character":36}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 265, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":19,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":266,"jsonrpc":"2.0","params":{"position":{"line":116,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 266, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":267,"jsonrpc":"2.0","params":{"position":{"line":116,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 267, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":268,"jsonrpc":"2.0","params":{"range":{"start":{"line":116,"character":12},"end":{"line":116,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 268, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":21,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":269,"jsonrpc":"2.0","params":{"position":{"line":116,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 269, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":270,"jsonrpc":"2.0","params":{"position":{"line":123,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 45.7499027252ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 270, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":271,"jsonrpc":"2.0","params":{"range":{"start":{"line":123,"character":12},"end":{"line":123,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 271, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":23,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":272,"jsonrpc":"2.0","params":{"position":{"line":123,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 272, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":273,"jsonrpc":"2.0","params":{"position":{"line":123,"character":48},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 273, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":274,"jsonrpc":"2.0","params":{"range":{"start":{"line":123,"character":48},"end":{"line":123,"character":48}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 274, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":275,"jsonrpc":"2.0","params":{"position":{"line":123,"character":47},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 275, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":276,"jsonrpc":"2.0","params":{"range":{"start":{"line":123,"character":47},"end":{"line":123,"character":47}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 276, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":277,"jsonrpc":"2.0","params":{"position":{"line":125,"character":50},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 277, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":278,"jsonrpc":"2.0","params":{"range":{"start":{"line":125,"character":44},"end":{"line":125,"character":50}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 278, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":279,"jsonrpc":"2.0","params":{"position":{"line":123,"character":47},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 279, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":280,"jsonrpc":"2.0","params":{"range":{"start":{"line":123,"character":47},"end":{"line":123,"character":47}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 280, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":281,"jsonrpc":"2.0","params":{"position":{"line":123,"character":35},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0278949737549ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 281, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":282,"jsonrpc":"2.0","params":{"range":{"start":{"line":123,"character":35},"end":{"line":123,"character":47}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 282, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":25,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":283,"jsonrpc":"2.0","params":{"position":{"line":123,"character":35},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 283, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":284,"jsonrpc":"2.0","params":{"position":{"line":130,"character":35},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 284, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":285,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":35},"end":{"line":130,"character":35}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 285, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, Option r2)\n          else if equals r r2 then\n            Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":27,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":286,"jsonrpc":"2.0","params":{"position":{"line":130,"character":23},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 286, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":287,"jsonrpc":"2.0","params":{"position":{"line":130,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 287, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":288,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":12},"end":{"line":130,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 288, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":29,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":289,"jsonrpc":"2.0","params":{"position":{"line":130,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 289, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/hover","id":290,"jsonrpc":"2.0","params":{"position":{"line":131,"character":15},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 290, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":291,"jsonrpc":"2.0","params":{"range":{"start":{"line":131,"character":15},"end":{"line":131,"character":15}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 291, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":292,"jsonrpc":"2.0","params":{"position":{"line":125,"character":16},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 292, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":293,"jsonrpc":"2.0","params":{"range":{"start":{"line":125,"character":16},"end":{"line":125,"character":16}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 293, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":294,"jsonrpc":"2.0","params":{"position":{"line":113,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 294, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":295,"jsonrpc":"2.0","params":{"range":{"start":{"line":113,"character":12},"end":{"line":113,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 295, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":296,"jsonrpc":"2.0","params":{"position":{"line":114,"character":18},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 296, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":297,"jsonrpc":"2.0","params":{"range":{"start":{"line":114,"character":18},"end":{"line":114,"character":18}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 297, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":298,"jsonrpc":"2.0","params":{"position":{"line":137,"character":11},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 298, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":299,"jsonrpc":"2.0","params":{"range":{"start":{"line":137,"character":11},"end":{"line":137,"character":11}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 299, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":300,"jsonrpc":"2.0","params":{"position":{"line":148,"character":11},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 300, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":301,"jsonrpc":"2.0","params":{"range":{"start":{"line":148,"character":11},"end":{"line":148,"character":11}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 301, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":302,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":24},"end":{"line":130,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 302, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":303,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":24},"end":{"line":130,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 303, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":304,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":24},"end":{"line":130,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 304, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":305,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":24},"end":{"line":130,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 305, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":306,"jsonrpc":"2.0","params":{"position":{"line":121,"character":22},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 306, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":307,"jsonrpc":"2.0","params":{"range":{"start":{"line":121,"character":22},"end":{"line":121,"character":22}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 307, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":308,"jsonrpc":"2.0","params":{"position":{"line":121,"character":21},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 308, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":309,"jsonrpc":"2.0","params":{"range":{"start":{"line":121,"character":21},"end":{"line":121,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 309, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":310,"jsonrpc":"2.0","params":{"position":{"line":123,"character":28},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 310, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":311,"jsonrpc":"2.0","params":{"range":{"start":{"line":123,"character":28},"end":{"line":123,"character":28}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 311, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":312,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":24},"end":{"line":130,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 312, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":313,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":24},"end":{"line":130,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 313, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":314,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":24},"end":{"line":130,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00476837158203ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 314, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":315,"jsonrpc":"2.0","params":{"position":{"line":121,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 315, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":316,"jsonrpc":"2.0","params":{"range":{"start":{"line":121,"character":24},"end":{"line":121,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 316, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":317,"jsonrpc":"2.0","params":{"position":{"line":130,"character":45},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 317, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":318,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":45},"end":{"line":130,"character":45}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 318, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":319,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":24},"end":{"line":130,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 319, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":320,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":24},"end":{"line":130,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 320, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, Option r2)\n          else if equals r r2 then\n            Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":31,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":321,"jsonrpc":"2.0","params":{"position":{"line":130,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 321, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":322,"jsonrpc":"2.0","params":{"position":{"line":130,"character":23},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 322, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":323,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":23},"end":{"line":130,"character":35}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 323, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":33,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":324,"jsonrpc":"2.0","params":{"position":{"line":123,"character":35},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 324, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":325,"jsonrpc":"2.0","params":{"range":{"start":{"line":123,"character":35},"end":{"line":123,"character":47}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 325, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":35,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":326,"jsonrpc":"2.0","params":{"position":{"line":123,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 326, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":327,"jsonrpc":"2.0","params":{"range":{"start":{"line":123,"character":12},"end":{"line":123,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 327, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":37,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":328,"jsonrpc":"2.0","params":{"position":{"line":116,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 328, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":329,"jsonrpc":"2.0","params":{"range":{"start":{"line":116,"character":12},"end":{"line":116,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 329, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":39,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":330,"jsonrpc":"2.0","params":{"position":{"line":116,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 330, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":331,"jsonrpc":"2.0","params":{"range":{"start":{"line":116,"character":24},"end":{"line":116,"character":36}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 331, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            Concat (r1, simplify @@ Union (r2, r2'))\n          else if equals r2 r2' then\n            Concat (simplify @@ Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, simplify @@ Option r2)\n          else if equals r r2 then\n            Concat (simplify @@ Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":41,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":332,"jsonrpc":"2.0","params":{"position":{"line":116,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 332, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":333,"jsonrpc":"2.0","params":{"position":{"line":123,"character":35},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 333, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":334,"jsonrpc":"2.0","params":{"range":{"start":{"line":123,"character":35},"end":{"line":123,"character":35}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 334, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":335,"jsonrpc":"2.0","params":{"position":{"line":130,"character":23},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0219345092773ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 335, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":336,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":23},"end":{"line":130,"character":23}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 336, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            Concat (r, Option r2)\n          else if equals r r2 then\n            Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":51,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":337,"jsonrpc":"2.0","params":{"position":{"line":130,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 337, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":338,"jsonrpc":"2.0","params":{"range":{"start":{"line":130,"character":24},"end":{"line":130,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 338, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":53,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/hover","id":339,"jsonrpc":"2.0","params":{"position":{"line":76,"character":18},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0238418579102ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 339, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":340,"jsonrpc":"2.0","params":{"range":{"start":{"line":76,"character":18},"end":{"line":76,"character":18}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 46.1311340332ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 340, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/hover","id":341,"jsonrpc":"2.0","params":{"position":{"line":76,"character":18},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 341, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":342,"jsonrpc":"2.0","params":{"position":{"line":78,"character":11},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 342, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":343,"jsonrpc":"2.0","params":{"range":{"start":{"line":78,"character":11},"end":{"line":78,"character":37}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 343, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":344,"jsonrpc":"2.0","params":{"position":{"line":78,"character":11},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 344, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":345,"jsonrpc":"2.0","params":{"position":{"line":81,"character":18},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0131130218506ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 345, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":346,"jsonrpc":"2.0","params":{"range":{"start":{"line":81,"character":18},"end":{"line":81,"character":18}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 346, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":347,"jsonrpc":"2.0","params":{"position":{"line":98,"character":26},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 347, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":348,"jsonrpc":"2.0","params":{"range":{"start":{"line":98,"character":26},"end":{"line":98,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 348, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> Osimplify @@ ption r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":55,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":349,"jsonrpc":"2.0","params":{"position":{"line":98,"character":38},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 349, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":57,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":350,"jsonrpc":"2.0","params":{"position":{"line":98,"character":26},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 350, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":351,"jsonrpc":"2.0","params":{"position":{"line":99,"character":21},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 351, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":352,"jsonrpc":"2.0","params":{"range":{"start":{"line":99,"character":21},"end":{"line":99,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 352, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> simplify @@ Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> Star r\n              | _ -> Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":59,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":353,"jsonrpc":"2.0","params":{"position":{"line":98,"character":38},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 353, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":354,"jsonrpc":"2.0","params":{"position":{"line":98,"character":26},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 354, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":355,"jsonrpc":"2.0","params":{"range":{"start":{"line":98,"character":26},"end":{"line":98,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 355, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":356,"jsonrpc":"2.0","params":{"position":{"line":107,"character":26},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 356, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":357,"jsonrpc":"2.0","params":{"range":{"start":{"line":107,"character":26},"end":{"line":107,"character":26}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 357, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> simplify @@ Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> simplify @@ Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":61,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":358,"jsonrpc":"2.0","params":{"position":{"line":107,"character":38},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 358, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/hover","id":359,"jsonrpc":"2.0","params":{"position":{"line":113,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 359, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":360,"jsonrpc":"2.0","params":{"range":{"start":{"line":113,"character":12},"end":{"line":113,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 360, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":361,"jsonrpc":"2.0","params":{"position":{"line":113,"character":20},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 361, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":362,"jsonrpc":"2.0","params":{"range":{"start":{"line":113,"character":20},"end":{"line":113,"character":20}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 362, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":363,"jsonrpc":"2.0","params":{"position":{"line":114,"character":19},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 363, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":364,"jsonrpc":"2.0","params":{"range":{"start":{"line":114,"character":19},"end":{"line":114,"character":19}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 364, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":365,"jsonrpc":"2.0","params":{"position":{"line":114,"character":19},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 365, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":366,"jsonrpc":"2.0","params":{"position":{"line":117,"character":20},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 366, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":367,"jsonrpc":"2.0","params":{"range":{"start":{"line":117,"character":20},"end":{"line":117,"character":20}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 367, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":368,"jsonrpc":"2.0","params":{"position":{"line":119,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 368, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":369,"jsonrpc":"2.0","params":{"range":{"start":{"line":119,"character":12},"end":{"line":119,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 369, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":370,"jsonrpc":"2.0","params":{"position":{"line":118,"character":25},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 370, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":371,"jsonrpc":"2.0","params":{"range":{"start":{"line":118,"character":25},"end":{"line":118,"character":25}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 371, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":372,"jsonrpc":"2.0","params":{"position":{"line":122,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0131130218506ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 372, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":373,"jsonrpc":"2.0","params":{"range":{"start":{"line":122,"character":12},"end":{"line":122,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 373, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":374,"jsonrpc":"2.0","params":{"position":{"line":116,"character":24},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 374, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":375,"jsonrpc":"2.0","params":{"range":{"start":{"line":116,"character":24},"end":{"line":116,"character":24}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 375, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":376,"jsonrpc":"2.0","params":{"position":{"line":121,"character":16},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 376, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":377,"jsonrpc":"2.0","params":{"range":{"start":{"line":121,"character":16},"end":{"line":121,"character":16}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 377, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":378,"jsonrpc":"2.0","params":{"position":{"line":123,"character":30},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 378, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":379,"jsonrpc":"2.0","params":{"range":{"start":{"line":123,"character":30},"end":{"line":123,"character":30}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 379, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":380,"jsonrpc":"2.0","params":{"position":{"line":127,"character":21},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 380, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":381,"jsonrpc":"2.0","params":{"range":{"start":{"line":127,"character":21},"end":{"line":127,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 381, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":382,"jsonrpc":"2.0","params":{"position":{"line":136,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0350475311279ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 382, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":383,"jsonrpc":"2.0","params":{"range":{"start":{"line":136,"character":12},"end":{"line":136,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 383, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":384,"jsonrpc":"2.0","params":{"position":{"line":137,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 384, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":385,"jsonrpc":"2.0","params":{"range":{"start":{"line":137,"character":12},"end":{"line":137,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 385, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":386,"jsonrpc":"2.0","params":{"position":{"line":148,"character":13},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 386, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":387,"jsonrpc":"2.0","params":{"range":{"start":{"line":148,"character":13},"end":{"line":148,"character":13}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 387, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":388,"jsonrpc":"2.0","params":{"position":{"line":148,"character":13},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 388, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":389,"jsonrpc":"2.0","params":{"position":{"line":148,"character":12},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 389, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":390,"jsonrpc":"2.0","params":{"range":{"start":{"line":148,"character":12},"end":{"line":148,"character":12}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 390, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":391,"jsonrpc":"2.0","params":{"position":{"line":146,"character":13},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 391, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":392,"jsonrpc":"2.0","params":{"range":{"start":{"line":146,"character":13},"end":{"line":146,"character":13}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 392, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":393,"jsonrpc":"2.0","params":{"position":{"line":148,"character":13},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 393, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":394,"jsonrpc":"2.0","params":{"range":{"start":{"line":148,"character":13},"end":{"line":148,"character":13}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 394, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":395,"jsonrpc":"2.0","params":{"position":{"line":151,"character":21},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 395, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":396,"jsonrpc":"2.0","params":{"range":{"start":{"line":151,"character":21},"end":{"line":151,"character":21}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 396, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> simplify @@ Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> simplify @@ Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> simplify @@ Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> Star r'\n        | Plus r' -> Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":62,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":397,"jsonrpc":"2.0","params":{"position":{"line":151,"character":33},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 397, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","id":398,"jsonrpc":"2.0","params":{"position":{"line":152,"character":16},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 398, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":399,"jsonrpc":"2.0","params":{"range":{"start":{"line":152,"character":16},"end":{"line":152,"character":16}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 399, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/hover","id":400,"jsonrpc":"2.0","params":{"position":{"line":151,"character":16},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 400, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":401,"jsonrpc":"2.0","params":{"range":{"start":{"line":151,"character":16},"end":{"line":151,"character":16}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 401, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":402,"jsonrpc":"2.0","params":{"position":{"line":158,"character":23},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0112056732178ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 402, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":403,"jsonrpc":"2.0","params":{"range":{"start":{"line":158,"character":23},"end":{"line":158,"character":23}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 403, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> simplify @@ Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> simplify @@ Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> simplify @@ Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> simplify @@ Star r'\n        | Plus r' -> simplify @@ Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":64,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":404,"jsonrpc":"2.0","params":{"position":{"line":158,"character":35},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 404, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module type S = sig\n\n  type lt\n  type t\n\n  val letter : lt -> t\n  val concat : t -> t -> t\n  val union : t -> t -> t\n  val star : t -> t\n\n  val equals : t -> t -> bool\n\n  (* val normalize : t -> t *)\n  val simplify : t -> t\n\n  val to_string : t -> string\n  (* val from_string : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter.Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  type t =\n    | Letter of lt\n    | Concat of t * t\n    | Union of t * t\n    | Star of t\n    | Plus of t\n    | Option of t\n\n  let letter (l : lt) : t =\n    Letter l\n  let concat (r1 : t) \n             (r2 : t) : t =\n    Concat (r1, r2)\n  let union (r1 : t) \n            (r2 : t) : t =\n    Union (r1, r2)\n  let star (r : t) : t =\n    Star r\n\n  let rec equals (r1 : t)\n                 (r2 : t) : bool =\n    match r1, r2 with\n    | Letter l1, Letter l2 ->\n      Lt.compare l1 l2 = 0\n    | Concat (r11, r12), Concat (r21, r22) -> \n      equals r11 r21 && equals r12 r22\n    | Union (r11, r12), Union (r21, r22) ->\n         (equals r11 r21 && equals r12 r22)\n      || (equals r11 r22 && equals r12 r21)\n    | Star r1, Star r2\n    | Plus r1, Plus r2\n    | Option r1, Option r2 ->\n      equals r1 r2\n    | _, _ ->\n      false\n\n  let rec simplify (reg : t) : t =\n    match reg with\n    | Letter _ -> reg\n    | Concat (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l1, Letter l2 ->\n          if Lt.is_epsilon l1 && Lt.is_epsilon l2 then\n            Letter l1 (* Letter (Lt.epsilon) *)\n          else if Lt.is_epsilon l1 then\n            Letter l2\n          else if Lt.is_epsilon l2 then\n            Letter l1\n          else\n            Concat (Letter l1, Letter l2)\n        | Star r1, Star r2 ->\n          if equals r1 r2 then\n            Star r1\n          else\n            Concat (Star r1, Star r2)\n        | r1, Star r ->\n          if equals r1 r then\n            simplify @@ Plus r\n          else\n            Concat (r1, Star r)\n        | Star r, r2 ->\n          if equals r r2 then\n            simplify @@ Plus r\n          else\n            Concat (Star r, r2)\n        | r1, r2 -> Concat (r1, r2)\n      end\n    | Union (r1, r2) ->\n      begin\n        match simplify r1, simplify r2 with\n        | Letter l, r ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> simplify @@ Option r\n            end\n          else\n            Union (Letter l, r)\n        | r, Letter l ->\n          if Lt.is_epsilon l then\n            begin\n              match r with\n              | Plus r -> simplify @@ Star r\n              | _ -> simplify @@ Option r\n            end\n          else\n            Union (r, Letter l)\n        | Concat (r1, r2), Concat (r1', r2') ->\n          if equals r1 r1' && equals r2 r2' then\n            Concat (r1, r2)\n          else if equals r1 r1' then\n            simplify @@ Concat (r1, Union (r2, r2'))\n          else if equals r2 r2' then\n            simplify @@ Concat (Union (r1, r1'), r2)\n          else\n            Union (Concat (r1, r2), Concat (r1', r2'))\n        | r, Concat (r1, r2) ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (r, Concat (r1, r2))\n        | Concat (r1, r2), r ->\n          if equals r r1 then\n            simplify @@ Concat (r, Option r2)\n          else if equals r r2 then\n            simplify @@ Concat (Option r1, r)\n          else\n            Union (Concat (r1, r2), r)\n        | r1, r2 -> \n          if equals r1 r2 then\n            r1\n          else\n            Union (r1, r2)\n      end\n    | Star r ->\n      begin\n        match simplify r with\n        | Letter l ->\n          if Lt.is_epsilon l then\n            Letter l (* Letter (Lt.epsilon) *)\n          else\n            Star (Letter l)\n        | Plus r'\n        | Option r'\n        | Star r' -> simplify @@ Star r'\n        | r' -> Star r'\n      end\n    | Plus r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Option r' -> simplify @@ Star r'\n        | Plus r' -> simplify @@ Plus r'\n        | r' -> Plus r'\n      end\n    | Option r ->\n      begin\n        match simplify r with\n        | Star r'\n        | Plus r' -> simplify @@ Star r'\n        | r' -> Option r'\n      end\n\n  let rec to_string (reg : t) : string =\n    match reg with\n    | Letter l ->\n      Lt.to_string l\n    | Concat (r1, r2) ->\n      to_string r1 ^ to_string r2\n    | Union (r1, r2) ->\n      \"(\" ^ to_string r1 ^ \"|\" ^ to_string r2 ^ \")\"\n    | Star r ->\n      \"(\" ^ to_string r ^ \")*\"\n    | Plus r ->\n      \"(\" ^ to_string r ^ \")+\"\n    | Option r ->\n      \"(\" ^ to_string r ^ \")?\"\n\nend"}],"textDocument":{"version":65,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":405,"jsonrpc":"2.0","params":{"position":{"line":166,"character":33},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 405, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":406,"jsonrpc":"2.0","params":{"range":{"start":{"line":166,"character":33},"end":{"line":166,"character":33}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 406, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":407,"jsonrpc":"2.0","params":{"range":{"start":{"line":166,"character":33},"end":{"line":166,"character":33}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 407, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":408,"jsonrpc":"2.0","params":{"range":{"start":{"line":166,"character":33},"end":{"line":166,"character":33}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 408, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":409,"jsonrpc":"2.0","params":{"range":{"start":{"line":10,"character":25},"end":{"line":10,"character":25}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 409, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/regexp/regexp.mli"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib/regexp
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/regexp/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":410,"jsonrpc":"2.0","params":{"range":{"start":{"line":15,"character":16},"end":{"line":15,"character":16}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 410, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/hover","id":411,"jsonrpc":"2.0","params":{"position":{"line":35,"character":57},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 411, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":412,"jsonrpc":"2.0","params":{"range":{"start":{"line":35,"character":57},"end":{"line":35,"character":57}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 412, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","id":413,"jsonrpc":"2.0","params":{"position":{"line":24,"character":0},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 413, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/codeAction","id":414,"jsonrpc":"2.0","params":{"range":{"start":{"line":24,"character":0},"end":{"line":31,"character":147}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":2,"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 414, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didChange","jsonrpc":"2.0","params":{"contentChanges":[{"text":"module StringS = struct\n\n  type symbol = string\n  type t = string\n\n  let compare : t -> t -> int = String.compare\n  let to_string (s : t) : string = s\n  (* let of_string (s : string) : t = s *)\n\n  let epsilon = \"\"\n  let is_epsilon (s : t) : bool = \n    s = epsilon\n\n  let get (s : t) : symbol option =\n    match s with\n    | \"\" -> None\n    | _ -> Some s\n  let symbol (s : symbol) : t = s\n\nend\n\nlet string_to_string_list (s : string) : string list =\n  List.map (fun c -> String.make 1 c) @@ List.of_seq @@ String.to_seq s\n\n(* module R = Regexp.Make(StringS)\n\nlet reg1 = R.(union (letter \"b\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"b\")\nlet reg2 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"b\") @@ letter \"b\")\nlet reg3 = R.(union (letter \"a\") @@ concat (letter \"a\") @@ concat (star @@ letter \"a\") @@ letter \"a\")\n\nlet () = Printf.printf \"r1 : %s\\nr2 : %s\\nr3 : %s\\n\" (R.to_string reg1) (R.to_string reg2) (R.to_string reg3)\nlet () = Printf.printf \"\\nr1 : %s\\nr2 : %s\\nr3 : %s\\n\" R.(to_string @@ simplify reg1) R.(to_string @@ simplify reg2) R.(to_string @@ simplify reg3) *)\n\n(* module A = Automaton.Make(StringS)\n\nlet auto = A.create @@ List.map StringS.symbol [\"a\"; \"b\"]\nlet auto = A.add_states auto [1; 2; 3]\nlet auto = A.add_start auto 1\nlet auto = A.add_end auto 3\nlet auto = A.add_transitions auto [(1, StringS.symbol \"a\", 1); (1, StringS.symbol \"b\", 1); (1, StringS.symbol \"b\", 2); (2, StringS.symbol \"b\", 3)]\nlet () = A.to_dot auto \"nfa\"\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic auto = true then \"true\" else \"false\")\nlet dfauto = A.determinize auto\nlet () = Printf.printf \"%s\\n\" (if A.is_deterministic dfauto = true then \"true\" else \"false\")\nlet () = A.to_dot dfauto \"dfa\" *)"}],"textDocument":{"version":44,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Read message 
{"method":"textDocument/documentHighlight","id":415,"jsonrpc":"2.0","params":{"position":{"line":24,"character":3},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 415, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Read message 
{"method":"textDocument/didSave","jsonrpc":"2.0","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/codeAction","id":416,"jsonrpc":"2.0","params":{"range":{"start":{"line":24,"character":3},"end":{"line":31,"character":147}},"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/src/main.ml"},"context":{"triggerKind":1,"only":["refactor","source"],"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/src
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/src
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 416, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/src/.merlin"}}
