Hello - from /home/p9romain/Téléchargements/Dev/ST3/rls-linux/reason-language-server
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 1, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"params":{},"jsonrpc":"2.0","method":"initialized"}
Read message 
{"params":{"textDocument":{"version":0,"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> state -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> state list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> state -> lt option -> state -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> trans list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> state -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> state list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> state -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> state list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> state -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> state list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> state -> lt option -> state -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> state -> state -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> state -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> state list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> state -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> state list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t","languageId":"ocaml","uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"}},"jsonrpc":"2.0","method":"textDocument/didOpen"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":26,"character":29}},"jsonrpc":"2.0","id":2}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0121593475342ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":26,"character":21},"end":{"line":26,"character":29}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":3}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":26,"character":29}},"jsonrpc":"2.0","id":4}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":31,"character":22}},"jsonrpc":"2.0","id":5}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":31,"character":22},"end":{"line":31,"character":22}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":6}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 6, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":35,"character":28}},"jsonrpc":"2.0","id":7}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":35,"character":20},"end":{"line":35,"character":28}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":8}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":24,"character":20},"end":{"line":24,"character":28}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":9}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 9, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":24,"character":28}},"jsonrpc":"2.0","id":10}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 10, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":24,"character":28}},"jsonrpc":"2.0","id":11}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":24,"character":28},"end":{"line":24,"character":28}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":12}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 12, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":72,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> trans list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":24,"character":25}},"jsonrpc":"2.0","id":13}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":13},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":24,"character":26}},"jsonrpc":"2.0","id":14}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 14, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":24,"character":26}},"jsonrpc":"2.0","id":15}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 15, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":24,"character":31}},"jsonrpc":"2.0","id":16}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 16, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":24,"character":31},"end":{"line":24,"character":31}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":17}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 17, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":34}},"jsonrpc":"2.0","id":18}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 18, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":37,"character":29},"end":{"line":37,"character":34}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":19}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 19, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":31,"character":37}},"jsonrpc":"2.0","id":20}
[server] Got a method textDocument/hover
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 20, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":31,"character":37},"end":{"line":31,"character":37}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":21}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 21, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":31,"character":37}},"jsonrpc":"2.0","id":22}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 22, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":74,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (trans) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":30},"context":{"triggerCharacter":"(","triggerKind":2,"isRetrigger":false}},"jsonrpc":"2.0","id":23}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 23, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":35}},"jsonrpc":"2.0","id":24}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 24, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"params":{"textDocument":{"version":77,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (in) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":32}},"jsonrpc":"2.0","id":25}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 25, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":25},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":32}},"jsonrpc":"2.0","id":26}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 26, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":26},"jsonrpc":"2.0","method":"$/cancelRequest"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"params":{"textDocument":{"version":79,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (int ) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":34}},"jsonrpc":"2.0","id":27}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 27, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":27},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":34}},"jsonrpc":"2.0","id":28}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 28, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":80,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (int *) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":35}},"jsonrpc":"2.0","id":29}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 29, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":81,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (int * ) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":36}},"jsonrpc":"2.0","id":30}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 30, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":30},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":36}},"jsonrpc":"2.0","id":31}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 31, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":31},"jsonrpc":"2.0","method":"$/cancelRequest"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"params":{"textDocument":{"version":84,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (int * lt ) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":39}},"jsonrpc":"2.0","id":32}
[server] Got a method textDocument/completion
[server] processing took 0.0121593475342ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 32, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":32},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":39}},"jsonrpc":"2.0","id":33}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 33, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":33},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"params":{"textDocument":{"version":91,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (int * lt option ) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":46}},"jsonrpc":"2.0","id":34}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 34, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":34},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":46}},"jsonrpc":"2.0","id":35}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 35, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":35},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"params":{"textDocument":{"version":94,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (int * lt option ** ) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":49}},"jsonrpc":"2.0","id":36}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 36, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":36},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":49}},"jsonrpc":"2.0","id":37}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 37, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":49}},"jsonrpc":"2.0","id":38}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 38, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":97,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (int * lt option * ) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":48}},"jsonrpc":"2.0","id":39}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 39, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":39},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":48}},"jsonrpc":"2.0","id":40}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 40, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":48}},"jsonrpc":"2.0","id":41}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 41, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":99,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (int * lt option * in) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":50}},"jsonrpc":"2.0","id":42}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 42, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":50}},"jsonrpc":"2.0","id":43}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 43, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":43},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":50}},"jsonrpc":"2.0","id":44}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 44, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":100,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"contentChanges":[{"text":"(* For the alphabet *)\nmodule type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  (* The empty automaton *)\n  val empty : t\n  (* [create alphabet] creates an empty automaton with the given alphabet [alphabet] *)\n  val create : lt list -> t\n\n  (* [add_state automaton state] adds [state] in [automaton]. \n     If it's already a state in [automaton], does nothing *)\n  val add_state : t -> int -> t\n  (* [add_states automaton states] adds several states in [automaton] *)\n  val add_states : t -> int list -> t\n  (* [add_trans automaton state1 letter state2] adds a transition labelled [letter] between [state1] and [state2] in [automaton].\n\n     Raises : [state1] and [state2] must be [automaton]'s states.\n\n     [letter] is either [None] for an epsilon-transition, either [Some l] otherwise.\n     Raises : [l] must be in the [automaton]'s alphabet.\n\n     If the transition is already in [automaton], does nothing *)\n  val add_trans : t -> int -> lt option -> int -> t\n  (* [add_transitions automaton transitions] adds several transitions in [automaton] *)\n  val add_transitions : t -> (int * lt option * int) list -> t\n  (* [add_start automaton state] sets [state] as a start state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_start : t -> int -> t\n  (* [add_starts automaton states] sets several states as start states in [automaton] *)\n  val add_starts : t -> int list -> t\n  (* [add_end automaton state] sets [state] as an end state in [automaton].\n     If it's already the case, does nothing\n\n     Raise : [state] must be an [automaton]'s state *)\n  val add_end : t -> int -> t\n  (* [add_ends automaton states] sets several states as end states in [automaton] *)\n  val add_ends : t -> int list -> t\n\n  (* [remove_state automaton state] removes [state] from [automaton]'s states.\n     If it isn't an [automaton]'s states, does nothing *)\n  val remove_state : t -> int -> t\n  (* [remove_states automaton states] removes several states in [automaton] *)\n  val remove_states : t -> int list -> t\n  (* [remove_trans automaton state1 letter state2] removes the given transitions from [automaton]'s transitions.\n     If it isn't an [automaton]'s transitions, does nothing *)\n  val remove_trans : t -> int -> lt option -> int -> t\n  (* [remove_all_trans_between automaton state1 state2] removes all transitions between [state1] and [state2] in [automaton] *)\n  val remove_all_trans_between : t -> int -> int -> t\n  (* [remove_start automaton state] unsets [state] as a start state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_start : t -> int -> t\n  (* [remove_starts automaton states] unsets several states as start state in [automaton] *)\n  val remove_starts : t -> int list -> t\n  (* [remove_end automaton state] unsets [state] as an end state in [automaton].\n     If it's already the case, does nothing *)\n  val remove_end : t -> int -> t\n  (* [remove_ends automaton states] unsets several states as end state in [automaton] *)\n  val remove_ends : t -> int list -> t\n\n  (* [to_dot automaton file_name] creates a dot file named \"[file_name].dot\" representing [automaton] *)\n  val to_dot : t -> string -> unit\n\n  (* [is_deterministic automaton] checks if [automaton] is deterministic.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val is_deterministic : t -> bool\n\n  (* [determinize automaton] returns an automaton which is the DFA version of [automaton].\n     If [automaton] has n states, the DFA automaton has at most 2^n states.\n\n     A deterministic finite automaton (or DFA) follows these 3 rules :\n     - Has one start state ;\n     - Has no epsilon-transitions ;\n     - For all states, there exists one and only one transition labelled by a same letter from it.\n        For instance, if we have (1, \"a\", 2) and (1, \"a\", 3), then it isn't deterministic *)\n  val determinize : t -> t\n  (* [get_rid_of_unreachable_states automaton] returns [automaton] without unreachable states *)\n  val get_rid_of_unreachable_states : t -> t\n  (* [minimize automaton] returns a minimized version of [automaton], the smallest possible \n\n     [automaton] must be a DFA without unreachable states *)\n  (* val minimize : t -> t *)\n\n  (* [check_word automaton word] checks if [word] is recognized by [automaton] *)\n  (* val check_word : t -> lt list -> bool *)\n\n  (* [to_regex automaton] returns the regex representing [automaton]. \n     The returned value might be unsimplified *)\n  (* val to_regex : t -> string *)\n  (* [from_regex rstring alphabet] parses [rstring] to create a NFA (Non-deterministic Finite Automaton) recognizing the regex *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":37,"character":51}},"jsonrpc":"2.0","id":45}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 45, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":102,"character":36}},"jsonrpc":"2.0","id":46}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 46, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":102,"character":36},"end":{"line":102,"character":36}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":47}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 47, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":0,"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> state -> t\n  val add_states : t -> state list -> t\n  val add_trans : t -> state -> lt option -> state -> t\n  val add_transitions : t -> trans list -> t\n  val add_start : t -> state -> t\n  val add_starts : t -> state list -> t\n  val add_end : t -> state -> t\n  val add_ends : t -> state list -> t\n\n  val remove_state : t -> state -> t\n  val remove_states : t -> state list -> t\n  val remove_trans : t -> state -> lt option -> state -> t\n  val remove_all_trans_between : t -> state -> state -> t\n  val remove_start : t -> state -> t\n  val remove_starts : t -> state list -> t\n  val remove_end : t -> state -> t\n  val remove_ends : t -> state list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend","languageId":"ocaml","uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"}},"jsonrpc":"2.0","method":"textDocument/didOpen"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":19,"character":26}},"jsonrpc":"2.0","id":48}
[server] Got a method textDocument/hover
[server] processing took 0.00619888305664ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 48, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":26}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":49}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 49, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":19,"character":28}},"jsonrpc":"2.0","id":50}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00619888305664ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 50, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"range":{"start":{"line":19,"character":23},"end":{"line":19,"character":28}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":51}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 51, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":72,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> trans list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":19,"character":26}},"jsonrpc":"2.0","id":52}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 52, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":52},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":19,"character":26}},"jsonrpc":"2.0","id":53}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 53, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":19,"character":26}},"jsonrpc":"2.0","id":54}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 54, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":34}},"jsonrpc":"2.0","id":55}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 55, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"range":{"start":{"line":22,"character":29},"end":{"line":22,"character":34}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":56}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 56, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":24,"character":31}},"jsonrpc":"2.0","id":57}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 57, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"range":{"start":{"line":24,"character":31},"end":{"line":24,"character":31}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":58}
[server] Got a method textDocument/codeAction
[server] processing took 0.018835067749ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 58, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":74,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> () list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":30},"context":{"triggerCharacter":"(","triggerKind":2,"isRetrigger":false}},"jsonrpc":"2.0","id":59}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0131130218506ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 59, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":30}},"jsonrpc":"2.0","id":60}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0150203704834ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 60, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"params":{"textDocument":{"version":76,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> (in) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":31}},"jsonrpc":"2.0","id":61}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 61, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":61},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":32}},"jsonrpc":"2.0","id":62}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 62, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":62},"jsonrpc":"2.0","method":"$/cancelRequest"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"params":{"textDocument":{"version":78,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> (int ) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":34}},"jsonrpc":"2.0","id":63}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 63, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":63},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":34}},"jsonrpc":"2.0","id":64}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 64, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":79,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> (int *) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":35}},"jsonrpc":"2.0","id":65}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 65, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":80,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> (int * ) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":36}},"jsonrpc":"2.0","id":66}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 66, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":66},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":36}},"jsonrpc":"2.0","id":67}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 67, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":67},"jsonrpc":"2.0","method":"$/cancelRequest"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"params":{"textDocument":{"version":83,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> (int * lt ) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":39}},"jsonrpc":"2.0","id":68}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 68, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":68},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":39}},"jsonrpc":"2.0","id":69}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 69, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":69},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"params":{"textDocument":{"version":91,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> (int * lt option *) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":46}},"jsonrpc":"2.0","id":70}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 70, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":70},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":47}},"jsonrpc":"2.0","id":71}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 71, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":71},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"params":{"textDocument":{"version":92,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> (int * lt option * ) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":48}},"jsonrpc":"2.0","id":72}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 72, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"id":72},"jsonrpc":"2.0","method":"$/cancelRequest"}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":48}},"jsonrpc":"2.0","id":73}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 73, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"version":94,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> (int * lt option * it) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":50}},"jsonrpc":"2.0","id":74}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 74, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":50}},"jsonrpc":"2.0","id":75}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 75, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"params":{"textDocument":{"version":97,"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"contentChanges":[{"text":"module type Letter = sig\n\n  type t\n\n  val compare : t -> t -> int\n  val to_string : t -> string\n  val of_string : string -> t\n\nend\n\nmodule type S = sig\n\n  type lt\n\n  type t\n\n  val empty : t\n  val create : lt list -> t\n\n  val add_state : t -> int -> t\n  val add_states : t -> int list -> t\n  val add_trans : t -> int -> lt option -> int -> t\n  val add_transitions : t -> (int * lt option * int) list -> t\n  val add_start : t -> int -> t\n  val add_starts : t -> int list -> t\n  val add_end : t -> int -> t\n  val add_ends : t -> int list -> t\n\n  val remove_state : t -> int -> t\n  val remove_states : t -> int list -> t\n  val remove_trans : t -> int -> lt option -> int -> t\n  val remove_all_trans_between : t -> int -> int -> t\n  val remove_start : t -> int -> t\n  val remove_starts : t -> int list -> t\n  val remove_end : t -> int -> t\n  val remove_ends : t -> int list -> t\n\n  val to_dot : t -> string -> unit\n\n  val is_deterministic : t -> bool\n\n  val determinize : t -> t\n  val get_rid_of_unreachable_states : t -> t\n  (* val minimize : t -> t *)\n  \n  (* val check_word : t -> lt list -> bool *)\n\n  (* val to_regex : t -> string *)\n  (* val from_regex : string -> lt list -> t *)\n\nend\n\nmodule Make (Lt : Letter) : S with type lt = Lt.t = struct\n\n  type lt = Lt.t\n  module Letter = struct\n\n    include Lt\n\n    (* For eps transitions (None) *)\n    let compare_opt (letter : t option) \n                    (letter' : t option) : int =\n      match letter, letter' with\n      | Some letter, Some letter' -> compare letter letter'\n      | None, Some _ -> -1\n      | None, None -> 0\n      | Some _, None -> 1 \n\n  end\n  module LetterSet = Set.Make(Letter)\n  type alphabet = LetterSet.t\n\n\n  type state = int\n  module State = struct\n\n    type t = state\n\n    let compare : t -> t -> int = Int.compare\n\n  end\n  module StateSet = Set.Make(State)\n  type states = StateSet.t\n  (* useful for determinize *)\n  module StateSetSet = Set.Make(StateSet)\n  type states_set = StateSetSet.t\n  module StateSetHash = struct\n\n    type t = states\n\n    let equal : states -> states -> bool = StateSet.equal\n\n    let hash (states : t) : int =\n      StateSet.fold (\n        fun (state : state) \n            (acc : int) : int ->\n          Hashtbl.hash @@ state lxor acc\n      ) states 0\n     \n  end\n  module StateSetHashtbl = Hashtbl.Make(StateSetHash)\n\n\n  type trans = state * lt option * state\n  module Trans = struct\n\n    type t = trans\n\n    let compare (state1, letter, state2 : t) \n                (state1', letter', state2' : t) : int =\n      let c1 = State.compare state1 state1' in\n      match c1 with\n      | 0 ->\n        begin\n          let c2 = Letter.compare_opt letter letter' in\n          match c2 with\n          | 0 -> State.compare state2 state2'\n          | _ -> c2\n        end\n      | _ -> c1\n\n  end\n  module TransSet = Set.Make(Trans)\n  type transitions = TransSet.t\n\n\n  type t = { \n              alphabet : alphabet ; \n              states : states ; \n              starts : states ; \n              trans : transitions ; \n              ends : states ;\n           }\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n  let get_transition_from (automaton : t) \n                          (state : state) : transitions =\n    TransSet.filter (\n      fun (state', _, _) -> \n        State.compare state state' = 0\n    ) \n    automaton.trans\n\n  let get_transition_between (automaton : t) \n                             (state1 : state)\n                             (state2 : state) : transitions =\n    TransSet.filter (\n      fun (state1', _, state2') -> \n        State.compare state1 state1' = 0\n        && State.compare state2 state2' = 0\n    ) \n    automaton.trans\n\n  let get_transition_to (automaton : t) \n                        (state : state) : transitions =\n    TransSet.filter (\n      fun (_, _, state') -> \n        State.compare state state' = 0\n    ) \n    automaton.trans              \n\n\n  (* ================================================================= *)\n  (* ================================================================= *)\n  (* ================================================================= *)\n\n\n  let empty : t = { \n                    alphabet = LetterSet.empty ; \n                    states = StateSet.empty ; \n                    starts = StateSet.empty ; \n                    trans = TransSet.empty ;\n                    ends = StateSet.empty ; \n                  }\n\n  let create (alphabet : lt list) : t = \n    { empty with alphabet = LetterSet.of_list alphabet }\n\n\n\n  let add_state (automaton : t) \n                (state : state) : t =\n    { automaton with states = StateSet.add state automaton.states }\n\n  let add_states (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t ->\n        add_state acc state\n    ) \n    automaton states\n\n  let add_trans (automaton : t) \n                (state1 : state) \n                (letter : lt option)\n                (state2 : state) : t =\n    match StateSet.find_opt state1 automaton.states, StateSet.find_opt state2 automaton.states with\n    | Some _, Some _ ->\n      begin\n        let trans = (state1, letter, state2) in\n        match letter with\n        | None -> \n          { automaton with trans = TransSet.add trans automaton.trans }\n        | Some letter ->\n          begin\n            match LetterSet.find_opt letter automaton.alphabet with\n            | Some _ -> \n              { automaton with trans = TransSet.add trans automaton.trans }\n            | None -> failwith \"given letter isn't in the automaton's alphabet\"\n          end\n      end\n    | _ -> failwith \"both given states must be automaton's states\"\n\n  let add_transitions (automaton : t) \n                      (transitions : trans list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state1, letter, state2 : trans) : t -> \n        add_trans acc state1 letter state2\n    ) \n    automaton transitions\n\n  let add_start (automaton : t) \n                (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with starts = StateSet.add state automaton.starts }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_starts (automaton : t) \n                 (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_start acc state\n    ) \n    automaton states\n\n  let add_end (automaton : t) \n              (state : state) : t =\n    match StateSet.find_opt state automaton.states with\n    | Some _ ->\n      { automaton with ends = StateSet.add state automaton.ends }\n    | None -> failwith \"given state must be an automaton's state\"\n\n  let add_ends (automaton : t) \n               (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        add_end acc state\n    ) \n    automaton states\n\n\n\n  let remove_state (automaton : t) \n                   (state : state) : t =\n    { automaton with states = StateSet.remove state automaton.states }\n\n  let remove_states (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_state acc state\n    ) \n    automaton states\n\n  let remove_trans (automaton : t) \n                   (state1 : state) \n                   (letter : lt option) \n                   (state2 : state) : t =\n    { automaton with trans = TransSet.remove (state1, letter, state2) automaton.trans }\n\n  let remove_all_trans_between (automaton : t) \n                               (state1 : state) \n                               (state2 : state) : t =\n    let transitions = TransSet.filter (\n      fun (s1, _, s2 : trans) : bool -> \n        State.compare state1 s1 <> 0 || State.compare state2 s2 <> 0 \n      ) \n      automaton.trans\n    in\n    { automaton with trans = transitions }\n\n  let remove_start (automaton : t) \n                   (state : state) : t =\n    { automaton with starts = StateSet.remove state automaton.starts }\n\n  let remove_starts (automaton : t) \n                    (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_start acc state\n    ) \n    automaton states\n\n  let remove_end (automaton : t) \n                 (state : state) : t =\n    { automaton with ends = StateSet.remove state automaton.ends }\n\n  let remove_ends (automaton : t) \n                  (states : state list) : t =\n    List.fold_left (\n      fun (acc : t) \n          (state : state) : t -> \n        remove_end acc state\n    ) \n    automaton states\n\n\n\n  let to_dot (automaton : t)\n             (file_name : string) : unit =\n    let file = open_out (file_name ^ \".dot\") in\n    Printf.fprintf file \"digraph automaton\\n{\\n\" ;\n    let i = ref 0 in\n    StateSet.iter ( \n      fun (state : state) : unit -> \n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ [label= \\\"\\\", shape=none,height=.0,width=.0] ;\\n\" !i ;\n        Printf.fprintf file \"  __INVISIBLE_NODE_%d__ -> %s ;\\n\" !i @@ string_of_int state ;\n        i := !i + 1\n    ) \n    automaton.starts ;\n    StateSet.iter ( \n      fun (state : state) : unit ->\n        Printf.fprintf file \"  %s [peripheries=2] ;\\n\" @@ string_of_int state \n    ) \n    automaton.ends ;\n    StateSet.iter (\n      fun (state1 : state) : unit ->\n        StateSet.iter (\n          fun (state2 : state) : unit ->\n            let letters = List.map (\n              fun (_, letter, _ : trans) : string ->\n                match letter with\n                | None -> \"ε\"\n                | Some letter -> Lt.to_string letter\n            ) \n              @@ TransSet.to_list \n              @@ get_transition_between automaton state1 state2 \n            in\n            let letter = String.concat \", \" letters in\n            if letter <> \"\" then \n              Printf.fprintf file \"  %s -> %s [label=\\\"%s\\\"] ;\\n\" (string_of_int state1) (string_of_int state2) letter\n          )\n          automaton.states\n      ) \n      automaton.states ;\n    Printf.fprintf file \"}\" ;\n    close_out file\n\n\n\n  let is_deterministic (automaton : t) : bool =\n    StateSet.cardinal automaton.starts = 1 (* Only one start state *)\n    (* No epsilon transition or same letter transition from a state *)\n    && \n    StateSet.for_all (\n      fun state ->\n        (* Get all transitions from the state *)\n        let transitions = get_transition_from automaton state in\n        (* Sort all the letters to see if there is more than once a letter *)\n        let letters = List.sort Letter.compare_opt @@ TransSet.fold (\n          fun (_, letter, _ : trans)\n              (acc : lt option list) : lt option list ->\n            letter :: acc\n        ) \n        transitions [] \n        in\n        (* Check *)\n        let rec check (letters : lt option list) \n                      (old_elt : lt option) : bool =\n          match letters with\n          | [] -> true\n          | elt :: letters ->\n            begin\n              match old_elt, elt with\n              (* epsilon transition *)\n              | _, None -> false\n              (* first letter *)\n              | None, _ ->\n                check letters elt\n              (* else : comparing previous letter checked with current letter*)\n              | Some letter, Some letter' ->\n                if Letter.compare letter letter' = 0 then\n                  false\n                else\n                  check letters elt\n            end\n        in\n        check letters None\n    )\n    automaton.states\n\n\n\n  let determinize (automaton : t) : t =\n    (* Only one start state (state nb = min-1)*)\n    let start_state = (+) (-1) \n      @@ StateSet.fold min automaton.states \n      @@ StateSet.choose automaton.states \n    in\n    (* Get its state name *)\n    let automaton = add_state automaton @@ start_state in\n    (* Link the new start state with previous start states *)\n    let automaton = StateSet.fold (\n      fun (state' : state)\n          (automaton : t) : t ->\n        add_trans automaton start_state None state'\n    ) \n    automaton.starts automaton \n    in\n    (* Removes old start states *)\n    let automaton = { automaton with starts = StateSet.empty } in\n    (* Add new start state *)\n    let automaton = add_start automaton start_state \n    in\n    (* To get rid of eps transitions *)\n    let eps_closure = Hashtbl.create 16 in\n    let () = StateSet.iter (\n      fun state ->\n        let rec get_accessible_states_with_eps_trans (state1 : state) \n                                                     (acc, already_done : states * states) : states =\n          (* all transitions *)\n          let transitions = get_transition_from automaton state1 in\n          (* keep only the eps transitions *)\n          let transitions = TransSet.filter (\n            fun (_, letter, _ : trans) : bool -> \n              match letter with\n              | None -> true\n              | _ -> false\n          ) \n          transitions \n          in\n          if TransSet.is_empty transitions then\n            acc\n          else\n            let states = TransSet.fold (\n              fun (_, _, state2 : trans) \n                  (acc : states) : states -> \n                StateSet.add state2 acc\n            ) \n            transitions StateSet.empty \n            in\n            StateSet.fold (\n              fun (state2 : state)\n                  (acc : states) : states ->\n                (* next state already done *)\n                if StateSet.mem state2 already_done then\n                  acc\n                else\n                (* we call on each next state [state2] and we add all his eps neighbours to [state1]'s ones*)\n                  StateSet.union acc \n                    @@ get_accessible_states_with_eps_trans state2\n                    @@ (StateSet.empty, StateSet.add state1 already_done)\n            ) \n            states StateSet.empty\n        in\n        (* eps_closure is a map from a state to a StateSet (the set of all the accessible states with eps transitions) *)\n        Hashtbl.replace eps_closure state \n          @@ StateSet.add state \n          @@ get_accessible_states_with_eps_trans state \n          @@ (StateSet.empty, StateSet.empty)\n    ) \n    automaton.states\n    in\n    (* Merging states \n      \n      key : states\n      value : (lt option * states) list\n\n      expl : {1, 2, 5} -> [ (\"a\", {1}) ; (\"b\", {1, 2, 5}) ; (\"c\", {}) ; (\"d\", {3, 4}) ]\n    *)\n    let new_trans = StateSetHashtbl.create 16 in\n    (* Starting with the StateSets of the start_state (stack) *)\n    let states_to_do = StateSetSet.add (Hashtbl.find eps_closure start_state) StateSetSet.empty in\n    let rec merge_transitions (states_to_do : states_set) \n                              (states_done : states_set) : unit =\n      if not @@ StateSetSet.is_empty states_to_do then\n        let states = StateSetSet.choose states_to_do in\n        let states_to_do = StateSetSet.remove states states_to_do \n        in\n        (* i_transitions : (lt option * states) list \n            = list of all possible next states\n          \n           n_to_do : states_set \n            = sett of all states we need to apply the algorithm\n        *)\n        let i_transitions, n_to_do = LetterSet.fold (\n          (* For all letter *)\n          fun (letter : lt)\n              (i_transitions, stack : (lt option * states) list * states_set ) : ((lt option * states) list * states_set) ->\n            (* For all states in states, we gather all the next states the accesible states with a transitions labelled letter *)\n            let next_states = StateSet.fold (\n              fun state1 acc ->\n                (* Get all transitions *)\n                let transitions = get_transition_from automaton state1 in\n                (* All transitions labelled [letter] *)\n                let transitions = TransSet.filter (\n                  fun (_, letter', _ : trans) : bool -> \n                    Letter.compare_opt letter' @@ Some letter = 0\n                ) \n                transitions \n                in\n                (* Sets of all possible next states *)\n                let next_states = TransSet.fold (\n                  fun (_, _, state2 : trans)\n                      (acc : states) : states ->\n                    StateSet.add state2 acc\n                )\n                transitions StateSet.empty \n                in\n                (* We join with the other accesible states *) \n                StateSet.union acc next_states\n            ) \n            states StateSet.empty \n            in\n            let n_stack =\n              (* We don't apply the function if\n                  - there aren't any transitions\n                  - or we already did the job\n                  - or it's a loop\n               *)\n              if StateSet.is_empty next_states || StateSetSet.mem next_states states_done || StateSet.compare next_states states = 0 then\n                stack\n              else\n                StateSetSet.add next_states stack\n            in\n            (* We add the transitions labelled [letter] from [states] to [next_states], \n               and we also return the new to_do_stack *)\n            (Some letter, next_states) :: i_transitions, n_stack\n        ) \n        automaton.alphabet ([], states_to_do) \n        in\n        let () = StateSetHashtbl.replace new_trans states i_transitions in\n        (* We keep_going the algo with the StateSet in the to_do list, and we add the current states to the done list since we just applied the algo to it*)\n        merge_transitions n_to_do @@ StateSetSet.add states states_done\n    in\n    let () = merge_transitions states_to_do StateSetSet.empty in\n    (* Renaming StateSet into a state \n       This is all the new states\n    *)\n    let states_name = StateSetHashtbl.create 16 in\n    let state_nb = ref 0 in\n    let () = StateSetHashtbl.iter (\n      fun (states : states) \n          (_ : (lt option * states) list) : unit -> \n        StateSetHashtbl.replace states_name states !state_nb ;\n        (* Small counter *)\n        state_nb := !state_nb + 1\n    ) \n    new_trans \n    in\n    (* Gather all new transitions *)\n    let transitions = StateSetHashtbl.fold (\n      fun (state : states)\n          (i_transitions : (lt option * states) list) \n          (acc : transitions) ->\n        (* State name ([state] is a set)*)\n        let state1 = StateSetHashtbl.find states_name state in\n        (* Add to the acc the new transitions *)\n        let transitions = List.fold_left (\n          fun (acc' : transitions) \n              (letter, states : lt option * states) : transitions ->\n            (* Transitions *)\n            if StateSet.is_empty states then\n              acc'\n            else\n              let trans = (state1, letter, StateSetHashtbl.find states_name states) in\n              TransSet.add trans acc'\n        ) \n        TransSet.empty i_transitions\n        in \n        TransSet.union acc transitions\n    )\n    new_trans TransSet.empty \n    in\n    (* Gather all end states *)\n    let end_states = StateSetHashtbl.fold (\n      fun (states : states) \n          (state_name : state) \n          (acc : states) : states ->\n        (* If one of the state in states (which is a StateSet) is an end state, then the state name of states is an end state *)\n       if StateSet.exists (fun (state : state) : bool -> StateSet.mem state states) automaton.ends then\n          StateSet.add state_name acc\n        else\n          acc\n    ) \n    states_name StateSet.empty\n    in\n    (* The DFA automaton *)\n    { \n      (* Same alphabet *)\n      alphabet = automaton.alphabet ; \n      (* Get all new states *)\n      states = StateSet.of_seq @@ StateSetHashtbl.to_seq_values states_name ;\n      (* Get the name of the state from its \"set name\" *)\n      starts = StateSet.add (StateSetHashtbl.find states_name @@ Hashtbl.find eps_closure start_state) StateSet.empty ; \n      (* Previously calculated transitions *)\n      trans = transitions ;\n      (* Previously calculated end states *)\n      ends = end_states ; \n    }\n\n  let get_rid_of_unreachable_states (automaton : t) : t =\n    let states = StateSet.fold (\n      fun (state : state)\n          (acc : states) : states ->\n        let rec get_all_accessible_states (state : state) : states =\n          let transitions = get_transition_from automaton state in\n          TransSet.fold (\n            fun (state1, _, state2 : trans)\n                (acc' : states)  : states ->\n              StateSet.union acc' \n                @@ StateSet.add state1 \n                @@ get_all_accessible_states state2\n          ) \n          transitions StateSet.empty\n        in\n        StateSet.union acc @@ get_all_accessible_states state\n    ) \n     automaton.starts StateSet.empty\n    in\n    { \n      alphabet = automaton.alphabet ; \n      states = states ;\n      starts = StateSet.filter (fun state -> StateSet.mem state states) automaton.starts ; \n      trans = TransSet.filter (fun (state, _, _) -> StateSet.mem state states) automaton.trans ;\n      ends = StateSet.filter (fun state -> StateSet.mem state states) automaton.ends ; \n    }\nend"}]},"jsonrpc":"2.0","method":"textDocument/didChange"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":22,"character":51}},"jsonrpc":"2.0","id":76}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 76, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"position":{"line":24,"character":31}},"jsonrpc":"2.0","id":77}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 77, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"range":{"start":{"line":24,"character":31},"end":{"line":24,"character":31}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":78}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 78, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"}},"jsonrpc":"2.0","method":"textDocument/didSave"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":102,"character":36},"end":{"line":102,"character":36}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":79}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 79, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"position":{"line":105,"character":47}},"jsonrpc":"2.0","id":80}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 80, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":105,"character":47},"end":{"line":105,"character":47}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":81}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 81, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"}},"jsonrpc":"2.0","method":"textDocument/didSave"}
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.mli"},"range":{"start":{"line":105,"character":47},"end":{"line":105,"character":47}},"context":{"only":["refactor","source"],"triggerKind":1,"diagnostics":[]}},"jsonrpc":"2.0","id":82}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 82, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"range":{"start":{"line":24,"character":31},"end":{"line":24,"character":31}},"context":{"triggerKind":2,"diagnostics":[]}},"jsonrpc":"2.0","id":83}
[server] Got a method textDocument/codeAction
[server] processing took 0.0290870666504ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 83, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
Read message 
{"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/MAG1/TER/lib/automaton.ml"},"range":{"start":{"line":24,"character":31},"end":{"line":24,"character":31}},"context":{"only":["refactor","source"],"triggerKind":1,"diagnostics":[]}},"jsonrpc":"2.0","id":84}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Found a `dune` file at /home/p9romain/rp/cours/MAG1/TER/lib
]] Making a new jbuilder package at /home/p9romain/rp/cours/MAG1/TER/lib
=== Project root: /home/p9romain/rp/cours/MAG1/TER
Detected `opam` dependency manager for local use
Sending response {"id": 84, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/MAG1/TER/lib/.merlin"}}
